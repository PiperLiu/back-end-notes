# 第六讲 thrift

- 作者：yxc
- 链接：https://www.acwing.com/file_system/file/content/whole/index/content/2991899/
- 来源：AcWing
- 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

<!-- @import "[TOC]" {cmd="toc" depthFrom=3 depthTo=3 orderedList=false} -->

<!-- code_chunk_output -->

- [thrift教程](#thrift教程)
- [项目：游戏匹配系统](#项目游戏匹配系统)
- [作业](#作业)

<!-- /code_chunk_output -->

细分目录：

<!-- @import "[TOC]" {cmd="toc" depthFrom=3 depthTo=4 orderedList=false} -->

<!-- code_chunk_output -->

- [thrift教程](#thrift教程)
- [项目：游戏匹配系统](#项目游戏匹配系统)
  - [项目基本架构](#项目基本架构)
  - [thrift中保存thrift接口](#thrift中保存thrift接口)
  - [thrift生成服务端](#thrift生成服务端)
  - [thrift生成客户端](#thrift生成客户端)
  - [深化client.py](#深化clientpy)
  - [拆分服务端逻辑（线程与锁）](#拆分服务端逻辑线程与锁)
  - [多线程与总结](#多线程与总结)
- [作业](#作业)

<!-- /code_chunk_output -->

### thrift教程

thrift 是一种 rpc 框架。

- thrift官网：https://thrift.apache.org/
- 上课代码地址：https://git.acwing.com/yxc/thrift_lesson

这节课是做一个项目。

### 项目：游戏匹配系统

#### 项目基本架构

![](./images/2021100401.png)

如上，用 `python3` 实现游戏部分， `C++` 实现 匹配部分。

代码已经有了：[../codes/thrift_lesson-master/readme.md](../codes/thrift_lesson-master/readme.md)

我们需要实现：
- 定义接口
- server
- client

#### thrift中保存thrift接口

首先定义了一个 `match.thrift` 文件。语法就参考 [https://gitbox.apache.org/repos/asf?p=thrift.git;a=blob;hb=HEAD;f=tutorial/tutorial.thrift](https://gitbox.apache.org/repos/asf?p=thrift.git;a=blob;hb=HEAD;f=tutorial/tutorial.thrift) 写下来就行。

```thrift
namespace cpp match_service

struct User {
    1: i32 id,
    2: string name,
    3: i32 score
}

service Match {

    /**
     * user: 添加的用户信息
     * info: 附加信息
     * 在匹配池中添加一个名用户
     */
    i32 add_user(1: User user, 2: string info),

    /**
     * user: 删除的用户信息
     * info: 附加信息
     * 从匹配池中删除一名用户
     */
    i32 remove_user(1: User user, 2: string info),
}
```

**经验：**
- 我们一般定义接口时，都带上 `info` 作为一个附加参数，这样以后不用更改接口，更改 `info` 就可以了
- `info` 可以是一个 `json`

#### thrift生成服务端

首先阅读文档 [https://thrift.apache.org/tutorial/cpp.html](https://thrift.apache.org/tutorial/cpp.html) ，看 CPP 接口怎么实现。

来到 `match_system/src` 目录：
```bash
thrift -r --gen cpp ../../thrift/match.thrift
```

如上就是为什么要定义 `namespace` 中 `cpp` 为 `match_service` 了：会通过 `thrift -r --gen cpp <.thrift>` 命令生成 `cpp` 文件。

然后整理一下目录结构。

在实现自己的逻辑前，先编译下，看看能不能跑通，跑通了再接着写代码。

```bash
g++ -c main.cpp match_server/*.cpp
```

然后链接：
```bash
g++ *.o -o main -lthrift
```

`-lthrift` 是辅助以 `thrift` 动态链接库。

然后 `./main` 就能运行。

#### thrift生成客户端

根据[https://thrift.apache.org/tutorial/py.html](https://thrift.apache.org/tutorial/py.html)命令：
```bash
thrift -r --gen py ../../thrift/match.thrift
```

发现现在 `game/src/match_client/match/gen-py/match_client/` 有一个可执行文件 `Match-remote` 是启动服务的文件。但是我们这边只用 `ptyhon` 做客户端实现，因此不需要这个，把这个删掉。

在 `src/` 创建一个 `client.py` ，把 [https://thrift.apache.org/tutorial/py.html](https://thrift.apache.org/tutorial/py.html) 改一下就行。

```python
from tutorial import Calculator
from tutorial.ttypes import InvalidOperation, Operation, Work

# 改为：
from match_client.match import Match
from match_client.match.ttypes import User
```

然后把没有用的都删掉。

把服务端跑起来，运行 `client.py` 就会有反应。

#### 深化client.py

参考[thrift_lesson-master/game/src/client.py](../codes/thrift_lesson-master/game/src/client.py)，通过 `stdin` 键入玩家信息。

`client.py` 就写完了。

#### 拆分服务端逻辑（线程与锁）

匹配系统应该是不断运行的，而匹配工作和写入数据库的工作应该不停循环，因此要开两个线程。

对于匹配任务，因为是单独一个线程，所以需要消费队列。

而实现消费队列需要用到锁。

锁有两个操作：
- `p` 操作，去获取一个锁
- `v` 操作，表示释放的意思

锁已经可以实现消费队列了。 C++ 中“条件变量”对锁是一个封装。

```cpp
struct MessageQueue
{
  queue<Task> q;
  mutex m;  // 锁
  condition_variable cv;  // 条件变量
} message_queue;

class MatchHandleer : virtual public MatchIf {
  public:
  MatchHandler () {

  }

  int32_t add_user(const User& user, const std::string& info) {
    ...

    // 这里 unique_lock
    // 加锁，不需要显示释放
    // 会等待 message_queue.m
    // 释放自动释放锁
    unique_lock<mutex> lck(message_queue.m);
    message_queue.q.push({user, "add"});

    return ;
  }
}
```

在消息队列里使用条件变量。

```cpp
void consume_task()
{
    while (true)
    {
        unique_lock<mutex> lck(message_queue.m);
        if (message_queue.q.empty())
        {
            // 如果是 empty
            // 则这里会导致 while (true) 死循环
            // 将导致 CPU 占用率 100%
            // 因此这用条件变量 cv
            // 将锁释放掉，一直卡在这里，直到唤醒条件变量
            // 唤醒的方式包括
            // cv.notify_all()
            // cv.notify_one() 等
            message_queue.cv.wait(lck);
        }
        else
        {
            auto task = message_queue.q.front();
            message_queue.q.pop();
            lck.unlock();

            if (task.type == "add") pool.add(task.user);
            else if (task.type == "remove") pool.remove(task.user);
        }
    }
}
```

#### 多线程与总结

y 总演示了多线程，也是从官网改吧改吧。

总结：
- y总从官网改就行
- 学到了 C++ 中锁与条件变量

### 作业
