# 第 11 章 AOF 持久化

<!-- @import "[TOC]" {cmd="toc" depthFrom=3 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [11.1 AOF 持久化的实现](#111-aof-持久化的实现)
  - [11.1.1 命令追加](#1111-命令追加)
  - [11.1.2 AOF 文件的写入与同步](#1112-aof-文件的写入与同步)
- [11.2 AOF 文件的载入与数据还原](#112-aof-文件的载入与数据还原)
- [11.3 AOF 重写](#113-aof-重写)
  - [11.3.1 AOF 文件重写的实现](#1131-aof-文件重写的实现)
  - [11.3.2 AOF 后台重写](#1132-aof-后台重写)

<!-- /code_chunk_output -->

Append Only File ，是另一种存储思路：不像 RDB 记录快照，而是记录操作路径。

### 11.1 AOF 持久化的实现

#### 11.1.1 命令追加

#### 11.1.2 AOF 文件的写入与同步

```
def eventLoop():
    while True:

    # 处理文件事件，接受命令请求以及发送命令回复
    # 处理命令请求时「可能」会有新的内容被追加到 aof_buf
    processFileEvents()

    # 处理时间事件
    processTimeEvents()

    # 考虑是否写 aof_buf 内容以及去写文件
    flushAppendOnlyFile()
```

### 11.2 AOF 文件的载入与数据还原

### 11.3 AOF 重写

AOF 应该压缩一批命令。

#### 11.3.1 AOF 文件重写的实现

过程很简单，即压缩一些相近的操作，合并成一个命令。

#### 11.3.2 AOF 后台重写

但这其中涉及到数据不一致的问题，书中的表格较好地简单阐述了如何解决该问题。

|时间|服务器进程（父进程）|子进程|
|---|---|---|
|1|执行命令 SET k1 v1| |
|2|执行命令 SET k2 v2| |
|3|执行命令 SET k3 v3| |
|4|创建子进程，执行 AOF 文件重写| |
|5|执行命令 SET k2 v4| 执行重写操作 |
|6|执行命令 SET k4 v4| 执行重写操作 |
|7|执行命令 SET k5 v5| 完成 AOF 文件重写，向父进程发送信号 |
|8|接受到子进程的信号，将命令 SET k2 v4 、 SET k4 v4 、 SET k5 v5 追加到 AOF 文件末尾| |
|9|用新的 AOF 文件替换旧的 AOF 文件| |
