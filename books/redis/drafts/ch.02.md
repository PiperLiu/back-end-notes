# 第 2 章 简单动态字符串

Redis 自己定义了一个字符串数据类型，叫做简单动态字符串（simple dynamic string, SDS）。

<!-- @import "[TOC]" {cmd="toc" depthFrom=3 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [2.1 SDS 的定义](#21-sds-的定义)
- [2.2 SDS 与 C 字符串的区别](#22-sds-与-c-字符串的区别)
  - [2.2.1 常数复杂度获取字符串的长度](#221-常数复杂度获取字符串的长度)
  - [2.2.2 杜绝缓冲区溢出](#222-杜绝缓冲区溢出)
  - [2.2.3 减少修改字符串时带来的内存重分配次数](#223-减少修改字符串时带来的内存重分配次数)
  - [2.2.4 二进制安全](#224-二进制安全)
  - [2.2.5 兼容部分 C 字符串函数](#225-兼容部分-c-字符串函数)
- [2.3 SDS API](#23-sds-api)
- [2.4 重点回顾](#24-重点回顾)
- [2.5 参考资料](#25-参考资料)

<!-- /code_chunk_output -->

### 2.1 SDS 的定义

```c
struct sdshdr {
    int len;   // buf 中已使用的
    int free;  // 记录 buf 中未使用的字节长度
    char buf[];
};

// 可直接
printf("%s", s->buf);
```

注意，还是要保证 `\0` 结尾的，因此要有 `len + free + 1 = buf 对应区域的长度` 。

### 2.2 SDS 与 C 字符串的区别

#### 2.2.1 常数复杂度获取字符串的长度

#### 2.2.2 杜绝缓冲区溢出

有 API 提供如 `sdscat(s, "Cluster");` 。

注意这里可以动态分配内存。

#### 2.2.3 减少修改字符串时带来的内存重分配次数

不可以每次操作都重新分配空间，毕竟 redis 是数据库。有两个策略：
1. 空间预分配（这里直接有个阈值，小于 1 MB 就二倍空间（free 分配同样大的空间）；大于 1 MB 就 free 为 1 MB）
2. 惰性释放空间

#### 2.2.4 二进制安全

并不是保存字符，而是保存一系列二进制数据。

#### 2.2.5 兼容部分 C 字符串函数

比如 `strcasecmp(sds->buf, "hello world");` 。

### 2.3 SDS API

### 2.4 重点回顾

### 2.5 参考资料
