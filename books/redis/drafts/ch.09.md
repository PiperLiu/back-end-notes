# 第 9 章 数据库

<!-- @import "[TOC]" {cmd="toc" depthFrom=3 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [9.1 服务器中的数据库](#91-服务器中的数据库)
- [9.2 切换数据库](#92-切换数据库)
- [9.3 数据库键空间（redisDb）](#93-数据库键空间redisdb)
  - [9.3.1 添加新键](#931-添加新键)
  - [9.3.2 删除键](#932-删除键)
  - [9.3.3 更新键](#933-更新键)
  - [9.3.4 对键取值](#934-对键取值)
  - [9.3.5 其他键空间操作](#935-其他键空间操作)
  - [9.3.6 读写键空间时的维护操作](#936-读写键空间时的维护操作)
- [9.4 设置键的生存时间或过期时间](#94-设置键的生存时间或过期时间)
  - [9.4.1 设置过期时间](#941-设置过期时间)
  - [9.4.2 保存过期时间](#942-保存过期时间)
  - [9.4.3 移除过期时间](#943-移除过期时间)
  - [9.4.4 计算并返回剩余剩余生存时间](#944-计算并返回剩余剩余生存时间)
  - [9.4.5 过期键的判定](#945-过期键的判定)
- [9.5 过期键删除策略](#95-过期键删除策略)
  - [9.5.1 定时删除](#951-定时删除)
  - [9.5.2 惰性删除](#952-惰性删除)
  - [9.5.3 定期删除](#953-定期删除)
- [9.6 Redis 的过期键删除策略](#96-redis-的过期键删除策略)
  - [9.6.1 惰性删除策略的实现](#961-惰性删除策略的实现)
  - [9.6.2 定期删除策略的实现（随机选取键判断是否过期）](#962-定期删除策略的实现随机选取键判断是否过期)
- [9.7 AOF 、 RDB 和复制功能对过期键的处理](#97-aof---rdb-和复制功能对过期键的处理)
  - [9.7.1 生成 RDB 文件](#971-生成-rdb-文件)
  - [9.7.2 载入 RDB 文件](#972-载入-rdb-文件)
  - [9.7.3 AOF 文件写入](#973-aof-文件写入)
  - [9.7.4 AOF 重写](#974-aof-重写)
  - [9.7.5 复制](#975-复制)
- [9.8 数据库通知](#98-数据库通知)
  - [9.8.1 发送通知](#981-发送通知)
  - [9.8.2 发送通知的实现](#982-发送通知的实现)

<!-- /code_chunk_output -->

问题：
1. 如何实现过期时间检查？
2. p110 随机获取过期键

### 9.1 服务器中的数据库

```c
struct redisServer {
    //...
    redisDb *db;
    int dbnum;
}
```

注意 db 是一个数组，虽然实际操作中我们很少切换数据库。

### 9.2 切换数据库

```c
typedef struct redisClient {
    // ...
    redisDb *db;
} redisClient;
```

切换命令： `SELECT 1` 。

### 9.3 数据库键空间（redisDb）

```c
typedef struct redisDb {
    // ...
    dict *dict;
}
```

对于如下操作：

```redis
redis> SET message "hello world"
OK
redis> RPUSH alphabets "a" "b" "c"
(integer) 3
redis> HSET myhash field1 "value1" field2 "value2"
(integer) 2
```

实际上，即在 `redisDbPtr->dict` 字典中插入了三个 item ：
- 每个 item 的 key 都是 `StringObject`
- vaule 则各有不同，如上依次被插入的是 `StringObject` 、 `ListObject` 和 `HashObject`

#### 9.3.1 添加新键

#### 9.3.2 删除键

#### 9.3.3 更新键

#### 9.3.4 对键取值

#### 9.3.5 其他键空间操作

#### 9.3.6 读写键空间时的维护操作

这里 redis 维护了一些其他数据库统计量：
- 如读取某个键后， hit 和 miss 计数器会被操作，可以通过 `info stats` 命令查看
- 键有自己的 LRU 时间戳，可以通过 `OBJECT idletime` 命令查看闲置时间
- 过期判断等
- WATCH 与 dirty 标记等
- 通知等

### 9.4 设置键的生存时间或过期时间

#### 9.4.1 设置过期时间

#### 9.4.2 保存过期时间

```c
typedef struct redisDb {
    // ...
    dict *expires;
}
```

`expires` 字典保存了所有设置了过期时间的键，key 是 `robj` 类型，value 是 `long long` 类型，保存了过期时间。

#### 9.4.3 移除过期时间

#### 9.4.4 计算并返回剩余剩余生存时间

#### 9.4.5 过期键的判定

### 9.5 过期键删除策略

#### 9.5.1 定时删除

优势：省内存

劣势：耗费 CPU 资源；若创建定时器，使用的是 Redis 服务器中的时间事件（在书中，其实现为无序链表，查找一个事件的时间复杂度为 O(N)）

#### 9.5.2 惰性删除

优势：剩 CPU

劣势：内存占用大

#### 9.5.3 定期删除

上述二者结合。

### 9.6 Redis 的过期键删除策略

#### 9.6.1 惰性删除策略的实现

db.c/expireIfNeeded

#### 9.6.2 定期删除策略的实现（随机选取键判断是否过期）

redis.c/activeExpireCycle

这里有一个十分工程的实现：
- 随机选取一个键检查是否过期 `redisDb.expires.get_random_key()` （伪代码）
- 若过期，则删除
- **若已达到时间上限，则停止处理**

再次应用了随机和时间上限，达到工程上的平衡（实现复杂性低、执行成本得到控制、效果由统计学“保证”）。

### 9.7 AOF 、 RDB 和复制功能对过期键的处理

#### 9.7.1 生成 RDB 文件

过期键不保存。

#### 9.7.2 载入 RDB 文件

主服务器处理过期键，从服务器不处理。不清楚为啥，估计是为了从服务器逻辑尽量简单。

#### 9.7.3 AOF 文件写入

过期键的删除类似 DEL 命令，被写入 AOF 文件。

#### 9.7.4 AOF 重写

“重写”时，过期键不被写入。

#### 9.7.5 复制

这里暂不记录主从服务器行为。

### 9.8 数据库通知

#### 9.8.1 发送通知

#### 9.8.2 发送通知的实现
